# !/usr/bin/env python3
# -*- coding: utf-8 -*-
"""RLC_circuit.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1M9r0ptT28-jl758yWoOMuYxKR82s5uJy

**Bibliotecas importadas**
"""

import numpy as np
import matplotlib.pyplot as plt

# ------------------------------------ #
# Definicao dos parametros do circuito #
R = 12.0
L = 10.0e-3
C = 50.0e-6

# --------------------------------------- #
# Fonte senoidal de excitacao do circuito #
f = 60.0
T = 1/f
Vs = 127.0
omega = 2*np.pi*f

# ------------------------------------ #
# Definicao de parametros da simulacao #
t_ini = 0.         # tempo de inicio da simulacao
t_end = 3.0*T      # tempo de final de simulacao
deltaT = 10.0e-6   # passo de simulacao/integracao = deltaT

tempo = np.arange(t_ini,t_end+deltaT,deltaT) # vetor de tempo da simulacao
nptos = tempo.shape[-1]  # numero de pontos da simulacao

t_k = t_ini        # tempo atual
t_ant = t_ini      # tempo anterior (t-deltaT)

n = 0  # contador

# ------------------------------------ #
# Definicao da matriz nodal modificada #
MNM = np.zeros((3,3)) # 2 nos + 1 fonte de tensao
vn_k = np.zeros((3,1)) 
JE_k = np.zeros((3,1))

vn_ant = vn_k; # vetor solução anterior

# --------------------------------------------------------------------- #
# Discretizacao do capacitor e indutor com o metodo de Euler regressivo #
Gl = deltaT / (2 * L)
Gc = (2 * C) / deltaT
Gr = 1 / R

# --------------- #
# Montagem da MNM #
# Contribuição do indutor
MNM[0][0] = MNM[0][0] + Gl
MNM[1][1] = MNM[1][1] + Gl
MNM[0][1] = MNM[0][1] - Gl
MNM[1][0] = MNM[1][0] - Gl
# Contribuição do capacitor
MNM[1][1] = MNM[1][1] + Gc
# Contribuição do resistor
MNM[1][1] = MNM[1][1] + Gr
# Contribuição da fonte de tensão
MNM[2][0] = MNM[2][0] + 1
MNM[0][2] = MNM[0][2] + 1

#MNM = np.array([[+Gl,       -Gl      ,+1.],
#                [-Gl,   (+Gl+Gc+Gr)  , 0.],
#                [+1 ,        0.      , 0.]])

invMNM = np.linalg.inv(MNM) # inversao da matriz nodal modificada

# -------------------------------------------------------------------- #
# saida de variaveis ( tensoes nodais + corrente pela fonte de tensao) #
out1 = np.zeros((nptos))
out2 = np.zeros((nptos))
out3 = np.zeros((nptos))

# ----------------- #
# Loop de simulacao #
while t_k < t_end:
    
    t_k = t_ant + deltaT  # tempo atual da simulacao
    
    # ---------------------------- #
    # Fonte de tensao independente #
    # ---------------------------- #
    vs_k = np.sqrt(2) * Vs * np.sin(omega * t_k)
    
    # ----------------------------------------- #
    # Cálculo das fontes de corrente do passado #
    # ----------------------------------------- #
    vc_ant = vn_ant[1][0] # tensao do no 2 do passado
    Jc_ant = (Gc - Gr) * vc_ant - vn_ant[2][0]
    JL_ant = Gl * (vn_ant[0][0] - vn_ant[1][0]) - vn_ant[2][0] #  corrente pela fonte de tensao multiplicada por -1
    
    # ----------------------------------------- #
    # Montagem do vetor de fontes independentes #
    # ----------------------------------------- #
    JE_k[0][0] =  - JL_ant
    JE_k[1][0] =  + JL_ant + Jc_ant
    JE_k[2][0] =  + vs_k

#    JE_k = np.array([[-JL_ant],
#                     [+JL_ant+Jc_ant],
#                     [+vs_k]])

    # -------------------------- #
    # Calculo das tensoes nodais #
    # -------------------------- #
    vn_k = np.dot(invMNM,JE_k)
    
    # ----------------------------------------- #
    # Atualizacao das tensoes nodais e contador #
    # ----------------------------------------- #
    n = n + 1
    vn_ant = vn_k
    t_ant = t_k

    # ------------------ #    
    # Saida de variaveis #
    # ------------------ #    
    out1[n] = vn_k[0][0]
    out2[n] = vn_k[1][0]
    out3[n] = vn_k[2][0]

"""**Saída gráfica dos valores simulados (tensões nodais + corrente pela fonte de tensão)**"""

plt.figure()
plt.plot(tempo, out1, tempo, out2, tempo, 5*out3)
plt.xlabel('tempo [s]')
plt.legend(['V_1','V_2','i_s'])
plt.show()
